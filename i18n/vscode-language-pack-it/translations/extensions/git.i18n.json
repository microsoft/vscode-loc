{
	"": [
		"--------------------------------------------------------------------------------------------",
		"Copyright (c) Microsoft Corporation. All rights reserved.",
		"Licensed under the MIT License. See License.txt in the project root for license information.",
		"--------------------------------------------------------------------------------------------",
		"Do not edit this file. It is machine generated."
	],
	"version": "1.0.0",
	"contents": {
		"package": {
			"displayName": "GIT",
			"description": "Integrazione SCM su Git",
			"command.clone": "Clona",
			"command.cloneRecursive": "Clona (ricorsivo)",
			"command.init": "Inizializza repository",
			"command.openRepository": "Apri repository",
			"command.close": "Chiudi repository",
			"command.refresh": "Aggiorna",
			"command.openChange": "Apri modifiche",
			"command.openAllChanges": "Apri tutte le modifiche",
			"command.openFile": "Apri file",
			"command.openHEADFile": "Apri File (HEAD)",
			"command.stage": "Prepara modifiche per commit",
			"command.stageAll": "Prepara tutte le modifiche per commit",
			"command.stageAllTracked": "Prepara per il commit tutte le modifiche non tracciate",
			"command.stageAllUntracked": "Prepara per commit tutte le modifiche non tracciate",
			"command.stageAllMerge": "Prepara per il commit tutte le modifiche di merge",
			"command.stageSelectedRanges": "Prepara per il commit intervalli selezionati",
			"command.revertSelectedRanges": "Ripristina intervalli selezionati",
			"command.stageChange": "Prepara modifica per commit",
			"command.revertChange": "Annulla modifica",
			"command.unstage": "Annulla preparazione modifiche per commit",
			"command.unstageAll": "Annulla preparazione di tutte le modifiche per commit",
			"command.unstageSelectedRanges": "Annulla preparazione per il commit di intervalli selezionati",
			"command.rename": "Rinomina",
			"command.clean": "Rimuovi modifiche",
			"command.cleanAll": "Rimuovi tutte le modifiche",
			"command.cleanAllTracked": "Rimuovi tutte le modifiche tracciate",
			"command.cleanAllUntracked": "Rimuovi tutte le modifiche non tracciate",
			"command.closeAllDiffEditors": "Chiudi tutti gli editor diff",
			"command.commit": "Esegui commit",
			"command.commitStaged": "Esegui commit dei file preparati",
			"command.commitEmpty": "Commit vuoto",
			"command.commitStagedSigned": "Esegui commit dei file preparati (approvazione)",
			"command.commitStagedAmend": "Esegui commit dei file preparati (modifica)",
			"command.commitAll": "Esegui commit di tutto",
			"command.commitAllSigned": "Esegui commit di tutto (approvazione)",
			"command.commitAllAmend": "Esegui commit di tutto (modifica)",
			"command.commitNoVerify": "Esegui commit (nessuna verifica)",
			"command.commitStagedNoVerify": "Esegui commit dei file preparati (nessuna verifica)",
			"command.commitEmptyNoVerify": "Commit vuoto (nessuna verifica)",
			"command.commitStagedSignedNoVerify": "Esegui commit dei file preparati (approvazione, nessuna verifica)",
			"command.commitStagedAmendNoVerify": "Esegui commit dei file preparati (modifica, nessuna verifica)",
			"command.commitAllNoVerify": "Esegui commit di tutto (nessuna verifica)",
			"command.commitAllSignedNoVerify": "Esegui commit di tutto (approvazione, nessuna verifica)",
			"command.commitAllAmendNoVerify": "Esegui commit di tutto (modifica, nessuna verifica)",
			"command.commitMessageAccept": "Accettare messaggio di commit",
			"command.commitMessageDiscard": "Rimuovere messaggio di commit",
			"command.restoreCommitTemplate": "Ripristina il modello di Commit",
			"command.undoCommit": "Annulla ultimo commit",
			"command.checkout": "Esegui checkout in...",
			"command.checkoutDetached": "Esegui checkout in (modalità scollegata)...",
			"command.branch": "Crea ramo...",
			"command.branchFrom": "Crea ramo da...",
			"command.deleteBranch": "Elimina ramo...",
			"command.renameBranch": "Rinomina Branch...",
			"command.cherryPick": "Esegui cherry-pick...",
			"command.merge": "Merge ramo...",
			"command.mergeAbort": "Interrompi merge",
			"command.rebase": "Riassegna ramo...",
			"command.createTag": "Crea tag",
			"command.deleteTag": "Elimina tag",
			"command.fetch": "Recupera",
			"command.fetchPrune": "Recupera (elimina)",
			"command.fetchAll": "Recupera da tutti gli elementi remoti",
			"command.pull": "Esegui pull",
			"command.pullRebase": "Esegui pull (Riassegna)",
			"command.pullFrom": "Pull da...",
			"command.push": "Esegui push",
			"command.pushForce": "Esegui push (Forza)",
			"command.pushTo": "Esegui push in...",
			"command.pushToForce": "Push in... (Forza)",
			"command.pushFollowTags": "Esegui push (segui tag)",
			"command.pushFollowTagsForce": "Esegui push (segui tag, forzato)",
			"command.pushTags": "Esegui push dei tag",
			"command.addRemote": "Aggiungi repository remoto...",
			"command.removeRemote": "Rimuovi repository remoto",
			"command.sync": "Sincronizza",
			"command.syncRebase": "Sincronizza (Rebase)",
			"command.publish": "Pubblica ramo...",
			"command.showOutput": "Mostra output GIT",
			"command.ignore": "Aggiungi a .gitignore",
			"command.revealInExplorer": "Visualizza nella vista Esplora risorse",
			"command.revealFileInOS.linux": "Aprire cartella superiore",
			"command.revealFileInOS.mac": "Visualizzare in Finder",
			"command.revealFileInOS.windows": "Visualizza in Esplora file",
			"command.rebaseAbort": "Interrompi riassegnazione",
			"command.stashIncludeUntracked": "Stash (includi non tracciate)",
			"command.stash": "Accantona",
			"command.stashPop": "Preleva accantonamento...",
			"command.stashPopLatest": "Preleva accantonamento più recente",
			"command.stashApply": "Applica Stash...",
			"command.stashApplyLatest": "Applica ultimo Stash",
			"command.stashDrop": "Rimuovi accantonamento...",
			"command.stashDropAll": "Rimuovi tutti gli accantonamenti...",
			"command.timelineOpenDiff": "Apri modifiche",
			"command.timelineCopyCommitId": "Copia ID commit",
			"command.timelineCopyCommitMessage": "Copia messaggio di commit",
			"command.timelineSelectForCompare": "Seleziona per il confronto",
			"command.timelineCompareWithSelected": "Confronta con selezionati",
			"command.api.getRepositories": "Ottieni Repository",
			"command.api.getRepositoryState": "Ottieni Stato repository",
			"command.api.getRemoteSources": "Ottieni Origini remote",
			"command.git.acceptMerge": "Completa merge",
			"command.git.openMergeEditor": "Risolvi nell'editor di merge",
			"command.git.runGitMerge": "Conflitti di calcolo con Git",
			"command.git.runGitMergeDiff3": "Conflitti di calcolo con GIT (Diff3)",
			"config.enabled": "Indica se GIT è abilitato.",
			"config.path": "Percorso e nome file dell'eseguibile GIT, ad esempio `C:\\Programmi\\Git\\bin\\git.exe` (Windows). Può trattarsi di una matrice di valori stringa che contengono più percorsi da cercare.",
			"config.autoRepositoryDetection": "Configura quando il repository dovrebbe essere rilevato automaticamente.",
			"config.autoRepositoryDetection.true": "Esegue la scansione per individuare le sottocartelle della cartella attualmente aperta e le cartelle padre dei file aperti.",
			"config.autoRepositoryDetection.false": "Disabilita la scansione automatica del repository.",
			"config.autoRepositoryDetection.subFolders": "Esegue la scansione per individuare le sottocartelle della cartella attualmente aperta.",
			"config.autoRepositoryDetection.openEditors": "Esegue la scansione per individuare le cartelle padre dei file aperti.",
			"config.autorefresh": "Indica se l'aggiornamento automatico è abilitato.",
			"config.autofetch": "Quando è impostata su true, i commit verranno recuperati automaticamente dal repository remoto del repository GIT corrente. Se è impostata su `all`, verranno recuperati da tutti i repository remoti.",
			"config.autofetchPeriod": "Durata in secondi tra ogni git fetch automatico, quando è abilitata l'opzione `#git.autofetch#`.",
			"config.confirmSync": "Confermare prima di sincronizzare i repository GIT.",
			"config.countBadge": "Controlla la notifica del conteggio GIT.",
			"config.countBadge.all": "Esegue il conteggio di tutte le modifiche.",
			"config.countBadge.tracked": "Esegue il conteggio solo delle revisioni.",
			"config.countBadge.off": "Disattiva il contatore.",
			"config.checkoutType": "Controlla il tipo di riferimenti GIT elencati quando si esegue `Esegui checkout in...`.",
			"config.checkoutType.local": "Rami locali",
			"config.checkoutType.tags": "Tag",
			"config.checkoutType.remote": "Rami remoti",
			"config.branchPrefix": "Prefisso usato per la creazione di un nuovo ramo.",
			"config.branchProtection": "Elenco di rami protetti. Per impostazione predefinita, viene visualizzato un prompt prima del commit delle modifiche in un ramo protetto. È possibile controllare la richiesta usando l'impostazione '#git.branchProtectionPrompt#'.",
			"config.branchProtectionPrompt": "Controlla se viene visualizzato un prompt prima del commit delle modifiche in un ramo protetto.",
			"config.branchProtectionPrompt.alwaysCommit": "Eseguire sempre il commit delle modifiche nel ramo protetto.",
			"config.branchProtectionPrompt.alwaysCommitToNewBranch": "Eseguire il commit delle modifiche apportate a un nuovo ramo.",
			"config.branchProtectionPrompt.alwaysPrompt": "Chiedere sempre conferma prima di eseguire il commit delle modifiche in un ramo protetto.",
			"config.branchRandomNameDictionary": "Elenco di dizionari usati per il nome del ramo generato in modo casuale. Ogni valore rappresenta il dizionario utilizzato per generare il segmento del nome del ramo. Dizionari supportati: 'aggettivi', 'animali', 'colori' e 'numeri'.",
			"config.branchRandomNameDictionary.adjectives": "Aggettivo casuale",
			"config.branchRandomNameDictionary.animals": "Nome animale casuale",
			"config.branchRandomNameDictionary.colors": "Nome colore casuale",
			"config.branchRandomNameDictionary.numbers": "Un un numero casuale compreso tra 100 e 999",
			"config.branchRandomNameEnable": "Controlla se viene generato un nome casuale durante la creazione di un nuovo ramo.",
			"config.branchValidationRegex": "Un'espressione regolare per validare i nomi delle nuove branch.",
			"config.branchWhitespaceChar": "Carattere per sostituire gli spazi vuoti nei nuovi nomi di ramo e per separare i segmenti di un nome di ramo generato in modo casuale.",
			"config.ignoreLegacyWarning": "Ignora l'avvertimento legacy di Git.",
			"config.ignoreMissingGitWarning": "Ignora il messaggio di avviso quando manca GIT.",
			"config.ignoreWindowsGit27Warning": "Ignora il messaggio di avviso quando Git 2.25 - 2.26 è installato in Windows.",
			"config.ignoreLimitWarning": "Ignora il messaggio di avviso quando ci sono troppe modifiche in un repository.",
			"config.ignoreRebaseWarning": "Ignora l'avviso quando il ramo potrebbe essere stato riassegnato durante il pull.",
			"config.defaultCloneDirectory": "Il percorso predefinito in cui clonare un repository GIT.",
			"config.useEditorAsCommitInput": "Controlla se verrà usato un editor full-text per creare messaggi di commit ogni volta che non viene specificato alcun messaggio nella casella di input di commit.",
			"config.verboseCommit": "Abilita l'output dettagliato quando '#git.useEditorAsCommitInput#' è abilitato.",
			"config.enableSmartCommit": "Eseguire il commit di tutte le modifiche quando non ci sono modifiche preparate.",
			"config.smartCommitChanges": "Controlla quali modifiche vengono automaticamente preparate per il commit da Commit intelligente.",
			"config.smartCommitChanges.all": "Prepara automaticamente tutte le modifiche per il commit.",
			"config.smartCommitChanges.tracked": "Solo modifiche tracciate automaticamente preparate per il commit.",
			"config.suggestSmartCommit": "Suggerisce di abilitare il commit intelligente (eseguire il commit di tutte le modifiche quando non ci sono modifiche preparate per il commit).",
			"config.enableCommitSigning": "Abilita la firma del commit con GPG o X.509.",
			"config.discardAllScope": "Controlla quali modifiche vengono rimosse tramite il comando `Rimuovi tutte le modifiche`. Con `all` vengono rimosse tutte le modifiche. Con `tracked` vengono rimossi solo i file di cui viene tenuta traccia. Con `prompt` viene visualizzata una finestra di dialogo ogni volta che si esegue l'azione.",
			"config.decorations.enabled": "Controlla se GIT aggiunge come contributo colori e notifiche nelle visualizzazioni Esplora risorse e Editor aperti.",
			"config.enableStatusBarSync": "Controlla se il comando Git Sync è visualizzato nella barra di stato.",
			"config.followTagsWhenSync": "Esegui il push di tutti i tag durante l'esecuzione del comando di sincronizzazione.",
			"config.promptToSaveFilesBeforeStash": "Controlla se GIT deve verificare la presenza di file non salvati prima di accantonare le modifiche.",
			"config.promptToSaveFilesBeforeStash.always": "Verifica la presenza di eventuali file non salvati.",
			"config.promptToSaveFilesBeforeStash.staged": "Verificare solo la presenza di file di stage non salvati.",
			"config.promptToSaveFilesBeforeStash.never": "Disabilita questo controllo.",
			"config.promptToSaveFilesBeforeCommit": "Controlla se GIT deve verificare la presenza di file non salvati prima di eseguire il commit.",
			"config.promptToSaveFilesBeforeCommit.always": "Verifica la presenza di eventuali file non salvati.",
			"config.promptToSaveFilesBeforeCommit.staged": "Verificare solo la presenza di file di stage non salvati.",
			"config.promptToSaveFilesBeforeCommit.never": "Disabilita questo controllo.",
			"config.postCommitCommand": "Esegui un comando Git dopo un commit riuscito.",
			"config.postCommitCommand.none": "Non eseguire alcun comando dopo un commit.",
			"config.postCommitCommand.push": "Esegui 'Git Push' dopo un commit riuscito.",
			"config.postCommitCommand.sync": "Esegui 'Git Pull' e 'Git Push' dopo un commit riuscito.",
			"config.rememberPostCommitCommand": "Ricorda l'ultimo comando Git eseguito dopo un commit.",
			"config.openAfterClone": "Controlla se aprire automaticamente un repository dopo la clonazione.",
			"config.openAfterClone.always": "Apri sempre nella finestra corrente.",
			"config.openAfterClone.alwaysNewWindow": "Apri sempre in una nuova finestra.",
			"config.openAfterClone.whenNoFolderOpen": "Apri solo nella finestra corrente quando non è alcuna cartella.",
			"config.openAfterClone.prompt": "Richiedi sempre l'azione da eseguire.",
			"config.showInlineOpenFileAction": "Controlla se visualizzare un'azione Apri file inline nella visualizzazione modifiche GIT.",
			"config.showPushSuccessNotification": "Controlla se visualizzare una notifica quando un push è avvenuto con successo.",
			"config.inputValidation": "Controlla quando visualizzare la convalida sull'input del messaggio di commit.",
			"config.inputValidationLength": "Controlla la soglia di lunghezza del messaggio di commit per mostrare un avviso.",
			"config.inputValidationSubjectLength": "Controlla la soglia relativa alla lunghezza dell'oggetto del messaggio di commit per la visualizzazione di un avviso. Disattivarlo per ereditare il valore di `config.inputValidationLength`.",
			"config.detectSubmodules": "Controlla se rilevare automaticamente i moduli secondari GIT.",
			"config.detectSubmodulesLimit": "Controlla il limite dei sottomoduli git rilevati.",
			"config.alwaysShowStagedChangesResourceGroup": "Mostra sempre il gruppo di risorse Modifiche preparate per il commit.",
			"config.alwaysSignOff": "Controlla il flag di signoff per tutti i commit.",
			"config.ignoreSubmodules": "Ignora le modifiche apportate ai moduli secondari nell'albero dei file.",
			"config.ignoredRepositories": "Elenco dei repository GIT da ignorare.",
			"config.scanRepositories": "Elenco dei percorsi in cui cercare i repository GIT.",
			"config.commandsToLog": "Elenco di comandi GIT (ad esempio commit, push) per i quali verrebbe registrato il relativo 'stdout' nel [git output](command:git.showOutput). Se per il comando GIT è configurato un hook lato client, verrà registrato anche il valore 'stdout' dell'hook lato client nel [git output](command:git.showOutput).",
			"config.showProgress": "Determina se le azioni git devono mostrare lo stato di avanzamento.",
			"config.rebaseWhenSync": "Forza git a usare rebase durante l'esecuzione del comando di sincronizzazione.",
			"config.confirmEmptyCommits": "Conferma sempre la creazione di commit vuoti per il comando 'Git: Commit vuoto'.",
			"config.fetchOnPull": "Quando è abilitato, recupera tutti i rami durante il pulling; altrimenti recupera solo il ramo corrente.",
			"config.pullBeforeCheckout": "Controlla se un ramo che non dispone di commit in uscita viene inoltrato rapidamente prima di essere estratto.",
			"config.pullTags": "Recupera tutti i tag durante il pull.",
			"config.pruneOnFetch": "Elimina durante il recupero.",
			"config.autoStash": "Accantona eventuali modifiche prima del pull e le ripristina dopo un pull riuscito.",
			"config.allowForcePush": "Controlla se il push forzato (con o senza lease) è abilitato.",
			"config.useForcePushWithLease": "Controlla se il push forzato usa la variante più sicura di forzatura con lease.",
			"config.confirmForcePush": "Controlla se chiedere conferma prima di eseguire il push forzato.",
			"config.allowNoVerifyCommit": "Controlla se consentire i commit senza l'esecuzione di hook pre-commit e commit-msg.",
			"config.confirmNoVerifyCommit": "Controlla se chiedere conferma prima di eseguire il commit senza verifica.",
			"config.closeDiffOnOperation": "Controllare se l'editor diff deve essere chiuso automaticamente quando le modifiche vengono accantonate, salvate, rimosse, preparate per il commit o non preparate per il commit.",
			"config.openDiffOnClick": "Controlla se aprire l'editor diff quando si fa clic su una modifica; in caso contrario verrà aperto l'editor normale.",
			"config.supportCancellation": "Controlla se durante l'esecuzione dell'azione Sync viene inviata una notifica, che consente all'utente di annullare l'operazione.",
			"config.branchSortOrder": "Controlla l'ordinamento per i rami.",
			"config.untrackedChanges": "Controlla il comportamento delle modifiche non tracciate.",
			"config.untrackedChanges.mixed": "Tutte le modifiche, tracciate e non tracciate, vengono visualizzate insieme e si comportano allo stesso modo.",
			"config.untrackedChanges.separate": "Le modifiche non tracciate vengono visualizzate separatamente nella visualizzazione Controllo del codice sorgente. Sono inoltre escluse da diverse azioni.",
			"config.untrackedChanges.hidden": "Le modifiche non tracciate vengono nascoste ed escluse da diverse azioni.",
			"config.requireGitUserConfig": "Controlla se richiedere la configurazione esplicita dell'utente GIT o lasciare che sia GIT a indovinarla se non è presente.",
			"config.showCommitInput": "Controlla se mostrare l'input del commit nel pannello del controllo del codice sorgente GIT.",
			"config.terminalAuthentication": "Controlla se abilitare VS Code come gestore di autenticazione per i processi GIT generati nel terminale integrato. Nota: per rendere effettiva una modifica di questa impostazione, è necessario riavviare i terminali.",
			"config.terminalGitEditor": "Controlla se abilitare VS Code come gestore di autenticazione per i processi GIT generati nel terminale integrato. Nota: per rendere effettiva una modifica di questa impostazione, è necessario riavviare i terminali.",
			"config.timeline.showAuthor": "Controlla se visualizzare l'autore del commit nella visualizzazione Sequenza temporale.",
			"config.timeline.showUncommitted": "Controlla se visualizzare le modifiche di cui non è stato eseguito il commit nella visualizzazione Sequenza temporale.",
			"config.timeline.date": "Controlla la data da usare per gli elementi nella visualizzazione Sequenza temporale.",
			"config.timeline.date.committed": "Usa la data di commit",
			"config.timeline.date.authored": "Usa la data di creazione",
			"config.useCommitInputAsStashMessage": "Controlla se usare il messaggio della casella di input di commit come messaggio predefinito per l'accantonamento.",
			"config.showActionButton": "Consente di controllare se è visualizzato un pulsante di azione nella visualizzazione del codice sorgente.",
			"config.showActionButton.commit": "Mostrare un pulsante di azione per eseguire il commit delle modifiche quando il ramo locale ha modificato i file pronti per il commit.",
			"config.showActionButton.publish": "Mostrare un pulsante di azione per pubblicare il ramo locale quando non è disponibile un ramo remoto di rilevamento.",
			"config.showActionButton.sync": "Mostrare un pulsante di azione per sincronizzare le modifiche quando il ramo locale è avanti o dietro il ramo remoto.",
			"config.statusLimit": "Controlla come limitare il numero di modifiche che è possibile analizzare dal comando di stato GIT. Può essere impostato su 0 per non porre alcun limite.",
			"config.experimental.installGuide": "Miglioramenti sperimentali per il flusso di installazione di GIT.",
			"config.repositoryScanIgnoredFolders": "Elenco di cartelle ignorate durante l'analisi dei repository GIT quando '#git.autoRepositoryDetection#' è impostato su 'true' o 'subFolders'.",
			"config.repositoryScanMaxDepth": "Controlla la profondità usata per l'analisi delle cartelle dell'area di lavoro per i repository GIT quando '#git.autoRepositoryDetection#' è impostato su 'true' o 'subFolders'. Può essere impostato su '-1' per nessun limite.",
			"config.useIntegratedAskPass": "Controlla se GIT_ASKPASS deve essere sovrascritto per usare la versione integrata.",
			"config.mergeEditor": "Apri l'editor merge per i file attualmente in conflitto.",
			"submenu.explorer": "GIT",
			"submenu.commit": "Esegui commit",
			"submenu.commit.amend": "Modifica",
			"submenu.commit.signoff": "Approva",
			"submenu.changes": "Modifiche",
			"submenu.pullpush": "Esegui pull/push",
			"submenu.branch": "Crea ramo",
			"submenu.remotes": "Repository remoto",
			"submenu.stash": "Accantona",
			"submenu.tags": "Tag",
			"colors.added": "Colore delle risorse aggiunte.",
			"colors.modified": "Colore delle risorse modificate.",
			"colors.stageModified": "Colore per le risorse modificate che sono state preparate per il commit.",
			"colors.stageDeleted": "Colore per le risorse eliminate che sono state preparate per il commit.",
			"colors.deleted": "Colore delle risorse eliminate.",
			"colors.renamed": "Colore delle risorse rinominate o copiate.",
			"colors.untracked": "Colore delle risorse non tracciate.",
			"colors.ignored": "Colore delle risorse ignorate.",
			"colors.conflict": "Colore delle risorse con conflitti.",
			"colors.submodule": "Colore delle risorse sottomodulo.",
			"view.workbench.scm.missing.windows": "[Download Git for Windows](https://git-scm.com/download/win)\r\nDopo l'installazione, [reload](command:workbench.action.reloadWindow) (o [troubleshoot](command:git.showOutput)). È possibile installare altri provider del controllo del codice sorgente [from the Marketplace](command:workbench.extensions.search?%22%40category%3A%5C%22scm%20provider%5C%22%22).",
			"view.workbench.scm.missing.mac": "[Download Git for macOS](https://git-scm.com/download/mac)\r\nDopo l'installazione, [reload](command:workbench.action.reloadWindow) (o [troubleshoot](command:git.showOutput)). È possibile installare altri provider del controllo del codice sorgente [from the Marketplace](command:workbench.extensions.search?%22%40category%3A%5C%22scm%20provider%5C%22%22).",
			"view.workbench.scm.missing.linux": "Il controllo del codice sorgente dipende dall'installazione di Git.\r\n[Download Git for Linux](https://git-scm.com/download/linux)\r\nDopo l'installazione, si prega di [reload](command:workbench.action.reloadWindow) (or [troubleshoot](command:git.showOutput)). È possibile installare altri provider del controllo del codice sorgente [from the Marketplace](command:workbench.extensions.search?%22%40category%3A%5C%22scm%20providers%5C%22%22).",
			"view.workbench.scm.missing": "Installare Git, un sistema di controllo del codice sorgente più richiesto, per tenere traccia delle modifiche al codice e collaborare con altri utenti. Per altre informazioni, vedere le [Git guides](https://aka.ms/vscode-scm).",
			"view.workbench.scm.disabled": "Se si vogliono usare le funzionalità GIT, abilitare GIT nelle [impostazioni](command:workbench.action.openSettings?%5B%22git.enabled%22%5D).\r\nPer altre informazioni su come usare GIT e il controllo del codice sorgente in VS Code, [leggere la documentazione](https://aka.ms/vscode-scm).",
			"view.workbench.scm.empty": "Per usare le funzionalità GIT, è possibile aprire una cartella contenente un repository GIT o clonarlo da un URL.\r\n[Apri cartella](command:vscode.openFolder)\r\n[Clona repository](command:git.clone)\r\nPer altre informazioni su come usare GIT e il controllo del codice sorgente in VS Code, [leggere la documentazione](https://aka.ms/vscode-scm).",
			"view.workbench.scm.folder": "La cartella attualmente aperta non contiene un repository GIT. È possibile inizializzare un repository che abiliterà le funzionalità di controllo del codice sorgente basate su GIT.\r\n[Inizializza repository](command:git.init?%5Btrue%5D)\r\nPer altre informazioni su come usare GIT e il controllo del codice sorgente in VS Code, [leggere la documentazione](https://aka.ms/vscode-scm).",
			"view.workbench.scm.workspace": "L'area di lavoro attualmente aperta non contiene cartelle con repository GIT. È possibile inizializzare un repository in una cartella che abiliterà le funzionalità di controllo del codice sorgente basate su GIT.\r\n[Inizializza repository](command:git.init)\r\nPer altre informazioni su come usare GIT e il controllo del codice sorgente in VS Code, [leggere la documentazione](https://aka.ms/vscode-scm).",
			"view.workbench.scm.emptyWorkspace": "L'area di lavoro attualmente aperta non contiene cartelle con repository GIT.\r\n[Aggiungi cartella all'area di lavoro](command:workbench.action.addRootFolder)\r\nPer altre informazioni su come usare GIT e il controllo del codice sorgente in VS Code, [leggere la documentazione](https://aka.ms/vscode-scm).",
			"view.workbench.cloneRepository": "È possibile clonare un repository in locale.\r\n[Clona repository](command:git.clone 'Clona un repository dopo l'attivazione dell'estensione GIT')",
			"view.workbench.learnMore": "Per altre informazioni su come usare GIT e il controllo del codice sorgente in VS Code, [leggere la documentazione](https://aka.ms/vscode-scm)."
		},
		"dist/main": {
			"validating": "Convalida del GIT trovato in: {0}",
			"skipped": "Il git trovato in: {0} è stato ignorato",
			"using git": "Uso di GIT {0} da {1}",
			"downloadgit": "Scarica GIT",
			"neverShowAgain": "Non visualizzare più questo messaggio",
			"notfound": "Git non trovato. Installarlo o configurarlo usando l'impostazione 'git.path'.",
			"updateGit": "Aggiorna GIT",
			"git20": "La versione installata di GIT è la {0}. Per il corretto funzionamento di Code è consigliabile usare una versione di GIT non inferiore alla 2.",
			"git2526": "La versione installata {0} di GIT causa problemi noti. Per il corretto funzionamento delle funzionalità GIT, è necessario eseguire l'aggiornamento a GIT >= 2.27."
		},
		"dist/askpass-main": {
			"missOrInvalid": "Credenziali mancanti o non valide."
		},
		"dist/model": {
			"not supported": "I percorsi assoluti non sono supportati nell'impostazione 'git.scanRepositories'.",
			"repoOnHomeDriveRootWarning": "Non è possibile aprire automaticamente il repository GIT in '{0}'. Per aprire il repository GIT, aprirlo direttamente come cartella in VS Code.",
			"too many submodules": "Il repository '{0}' ha {1} sottomoduli che non verranno aperti automaticamente. È possibile comunque aprirli individualmente aprendo il file all'interno.",
			"no repositories": "Non ci sono repository disponibili",
			"pick repo": "Scegli un repository"
		},
		"dist/commands": {
			"tag at": "Tag in {0}",
			"remote branch at": "Ramo remoto in {0}",
			"create branch": "Crea nuovo ramo...",
			"create branch from": "Crea nuovo ramo da...",
			"checkout detached": "Checkout scollegato...",
			"add remote": "Aggiungi un nuovo computer remoto...",
			"fetch all remotes": "{0} Recupera tutti i repository remoti",
			"Current": "Corrente",
			"Incoming": "In ingresso",
			"stashedChanges": "Stashed Changes",
			"clonefrom": "Clona da {0}",
			"repourl": "URL del repository",
			"selectFolderTitle": "Scegliere una cartella in cui clonare {0}",
			"selectFolder": "Seleziona il Percorso del Repository",
			"cloning": "Clonazione del repository GIT '{0}'...",
			"checking out ref": "Estrazione del riferimento '{0}'...",
			"proposeopen": "Aprire il repository clonato?",
			"openrepo": "Apri",
			"openreponew": "Apri in una nuova finestra",
			"add": "Aggiungi all'Area di Lavoro",
			"proposeopen2": "Vuoi aprire il repository clonato o aggiungerlo all'area di lavoro corrente?",
			"init": "Selezionare la cartella dell'area di lavoro in cui inizializzare il Git repo",
			"choose": "Scegli cartella...",
			"init repo": "Inizializza repository",
			"create repo": "Inizializza repository",
			"are you sure": "Questo creerà un repository Git in '{0}'. Sei sicuro di voler continuare?",
			"proposeopen init": "Aprire il repository inizializzato?",
			"proposeopen2 init": "Aprire il repository inizializzato o aggiungerlo all'area di lavoro corrente?",
			"open repo": "Apri repository",
			"HEAD not available": "La versione HEAD di '{0}' non è disponibile.",
			"confirm stage files with merge conflicts": "Preparare per il commit {0} file con conflitti di merge?",
			"confirm stage file with merge conflicts": "Preparare per il commit {0} con conflitti di merge?",
			"yes": "Sì",
			"keep ours": "Mantieni la versione dell'utente corrente",
			"delete": "Elimina file",
			"deleted by them": "Il file '{0}' è stato eliminato da altri utenti e modificato dall'utente corrente.\r\n\r\nCome si vuole procedere?",
			"keep theirs": "Mantieni la versione degli altri utenti",
			"deleted by us": "Il file '{0}' è stato eliminato dall'utente corrente e modificato da altri utenti.\r\n\r\nCome si vuole procedere?",
			"discard": "Rimuovi modifiche",
			"confirm delete": "ELIMINARE {0}? \r\nQuesta operazione è IRREVERSIBILE.\r\nSe si procede, questo file andrà PERSO DEFINITIVAMENTE.",
			"delete file": "Elimina file",
			"restore file": "Ripristina il file",
			"confirm restore": "Ripristinare {0}?",
			"confirm discard": "Rimuovere le modifiche in {0}?",
			"restore files": "Ripristina i file",
			"confirm restore multiple": "Ripristinare {0} file?",
			"confirm discard multiple": "Rimuovere le modifiche in {0} file?",
			"warn untracked": "{0} file non verificati verranno ELIMINATI.\r\nQuesta operazione è IRREVERSIBILE.\r\nQuesti file andranno PERSI DEFINITIVAMENTE.",
			"there are untracked files single": "Se rimosso, il file seguente di cui non viene tenuta traccia verrà ELIMINATO DAL DISCO: {0}.",
			"there are untracked files": "Se rimossi, {0} file di cui non viene tenuta traccia verranno ELIMINATI DAL DISCO.",
			"confirm discard all 2": "{0}\r\n\r\nQuesta operazione è IRREVERSIBILE. Il working set corrente andrà PERSO PER SEMPRE.",
			"yes discard tracked": "Rimuovi 1 file di cui viene tenuta traccia",
			"yes discard tracked multiple": "Rimuovi {0} file di cui viene tenuta traccia",
			"discardAll": "Rimuovi tutti i {0} file",
			"confirm discard all single": "Rimuovere le modifiche in {0}?",
			"confirm discard all": "Rimuovere TUTTE le modifiche apportate in {0} file?\r\nQuesta operazione è IRREVERSIBILE.\r\nSe si procede, il working set corrente andrà PERSO DEFINITIVAMENTE.",
			"discardAll multiple": "Rimuovi 1 file",
			"confirm delete multiple": "ELIMINARE {0} file? \r\nQuesta operazione è IRREVERSIBILE.\r\nSe si procede, questi file andranno PERSI DEFINITIVAMENTE.",
			"delete files": "Elimina file",
			"unsaved files single": "Il file seguente contiene modifiche non salvate che non verranno incluse nel commit se si procede: {0}.\r\n\r\nSalvarlo prima del commit?",
			"unsaved files": "Sono presenti {0} file non salvati.\r\n\r\nSalvarli prima di eseguire il commit?",
			"save and commit": "Salva tutto & esegui Commit",
			"commit": "Esegui commit delle modifiche per il commit",
			"no staged changes": "Non ci sono modifiche preparate per il commit di cui eseguire il commit.\r\n\r\nPreparare per il commit tutte le modifiche ed eseguirne il commit direttamente?",
			"always": "Sempre",
			"never": "Mai",
			"commit anyway": "Crea commit vuoto",
			"no changes": "Non ci sono modifiche di cui eseguire il commit.",
			"no verify commit not allowed": "I commit senza verifica non sono consentiti. Abilitarli con l'impostazione 'git.allowNoVerifyCommit'.",
			"confirm no verify commit": "Si sta per eseguire il commit delle modifiche senza verifica. Con questa operazione gli hook pre-commit verranno ignorati e tale comportamento può non essere quello desiderato.\r\n\r\nContinuare?",
			"ok": "OK",
			"never ask again": "OK, non visualizzare più questo messaggio",
			"commit to branch": "Eseguire il commit in un nuovo ramo",
			"confirm branch protection commit": "Si sta tentando di eseguire il commit in un ramo protetto e potrebbe non essere disponibile l'autorizzazione per eseguire il push dei commit nel ramo remoto.\r\n\r\nCome procedere?",
			"commit changes": "Eseguire comunque il commit",
			"commitMessageWithHeadLabel2": "Messaggio (commit in '{0}')",
			"commit message": "Messaggio di commit",
			"provide commit message": "Specificare un messaggio di commit",
			"confirm empty commit": "Creare un commit vuoto?",
			"yes never again": "Sì, non visualizzare più questo messaggio",
			"no more": "Non è possibile annullare l'operazione perché HEAD non fa riferimento ad alcun commit.",
			"undo commit": "Annulla commit di merge",
			"merge commit": "L'ultimo commit è stato un commit di merge. Annullarlo?",
			"select a ref to checkout detached": "Selezionare un riferimento per il checkout in modalità scollegata",
			"select a ref to checkout": "Selezionare un ref di cui eseguire checkout",
			"force": "Forza checkout",
			"stashcheckout": "Accantona ed esegui checkout",
			"local changes": "Le modifiche locali verranno sovrascritte dal checkout.",
			"branch name": "Nome ramo",
			"provide branch name": "Specificare un nuovo nome di ramo",
			"branch name does not match sanitized": "Il nuovo ramo sarà '{0}'",
			"branch name format invalid": "Il nome del ramo deve corrispondere all'espressione regex: {0}",
			"select a ref to create a new branch from": "Seleziona un riferimento da cui creare il ramo '{0}'",
			"select branch to delete": "Seleziona un ramo da cancellare",
			"confirm force delete branch": "Il merge del ramo '{0}' non è completo. Elimina comunque?",
			"delete branch": "Elimina ramo",
			"invalid branch name": "Nome di branch non valido",
			"branch already exists": "La branch denominata '{0}' esiste già",
			"select a branch to merge from": "Selezionare un ramo da cui eseguire il merge",
			"select a branch to rebase onto": "Selezionare un ramo in base a cui eseguire la riassegnazione",
			"tag name": "Nome tag",
			"provide tag name": "Specificare un nome di tag",
			"tag message": "Messaggio",
			"provide tag message": "Specificare un messaggio per aggiungere un'annotazione per il tag",
			"no tags": "Non esistono tag per questo repository.",
			"select a tag to delete": "Selezionare un tag da eliminare",
			"no remotes to fetch": "Questo repository non ha remote configurati da cui eseguire un fetch.",
			"select a remote to fetch": "Selezionare un repository remoto da recuperare",
			"no remotes to pull": "Il repository non contiene elementi remoti configurati come origini del pull.",
			"pick remote pull repo": "Selezionare un repository remoto da cui effettuare il pull del ramo",
			"pick branch pull": "Selezionare un ramo da cui eseguire il pull",
			"addremote": "Aggiungi repository remoto",
			"no remotes to push": "Il repository non contiene elementi remoti configurati come destinazione del push.",
			"force push not allowed": "Il push forzato non è consentito. Per abilitarlo, usare l'impostazione 'git.allowForcePush'.",
			"confirm force push": "Si sta per eseguire il push forzato delle modifiche. Questa operazione può essere distruttiva e comportare la sovrascrittura accidentale di modifiche apportate da altri utenti.\r\n\r\nContinuare?",
			"nobranch": "Estrarre un ramo per eseguire il push in un elemento remoto.",
			"confirm publish branch": "Il ramo '{0}' non dispone di un ramo remoto. Pubblicare questo ramo?",
			"pick remote": "Selezionare un repository remoto in cui pubblicare il ramo '{0}':",
			"commit hash": "Hash del commit",
			"provide commit hash": "Specificare l'hash del commit",
			"addfrom": "Aggiungi repository remoto da {0}",
			"addFrom": "Aggiungi repository remoto da URL",
			"remote name": "Nome del repository remoto",
			"provide remote name": "Specificare un nome di repository remoto",
			"remote name format invalid": "Il formato del nome di repository remoto non è valido",
			"remote already exists": "Il repository remoto '{0}' esiste già.",
			"no remotes added": "Il repository non contiene repository remoti.",
			"remove remote": "Scegliere un repository remoto da rimuovere",
			"sync is unpredictable": "Questa azione eseguirà il pull e il push dei commit da e verso '{0}/{1}'.",
			"never again": "OK, non visualizzare più",
			"no remotes to publish": "Il repository non contiene elementi remoti configurati come destinazione della pubblicazione.",
			"publish to": "Pubblica in {0}",
			"pick provider": "Seleziona un provider in cui pubblicare il ramo '{0}':",
			"no changes stash": "Non ci sono modifiche da accantonare.",
			"unsaved stash files single": "Il file seguente contiene modifiche non salvate che non verranno incluse nell'accantonamento se si procede: {0}.\r\n\r\nSalvarlo prima dell'accantonamento?",
			"unsaved stash files": "Sono presenti {0} file non salvati.\r\n\r\nSalvarli prima dell'accantonamento?",
			"save and stash": "Salva tutto e accantona",
			"stash": "Accantona comunque",
			"provide stash message": "Specificare un messaggio di accantonamento (facoltativo)",
			"stash message": "Messaggio di accantonamento",
			"pick stash to pop": "Scegli un accantonamento da prelevare",
			"no stashes": "Non ci sono accantonamenti nel repository.",
			"pick stash to apply": "Scegli un accantonamento da applicare",
			"pick stash to drop": "Selezionare un accantonamento da rimuovere",
			"sure drop": "Rimuovere l'accantonamento {0}?",
			"drop one stash": "Rimuovere TUTTI gli accantonamenti? È presente 1 accantonamento che verrà eliminato e POTREBBE ESSERE IMPOSSIBILE DA RECUPERARE.",
			"drop all stashes": "Rimuovere TUTTI gli accantonamenti? Sono presenti {0} accantonamenti che verranno eliminati e POTREBBERO ESSERE IMPOSSIBILI DA RECUPERARE.",
			"git.title.workingTree": "{0} (Albero di lavoro)",
			"git.title.index": "{0} (Indice)",
			"git.title.diffRefs": "{0} ({1}) ↔ {0} ({2})",
			"git.timeline.openDiffCommand": "Apri confronto",
			"git.title.ref": "{0} ({1})",
			"git.title.diff": "{0} ↔ {1}",
			"no rebase": "Non è in corso alcuna riassegnazione.",
			"open git log": "Apri log GIT",
			"show command output": "Mostra output del comando",
			"clean repo": "Pulire l'albero di lavoro del repository prima dell'estrazione.",
			"cant push": "Impossibile fare push dei ref su remoto. Provare a eseguire un 'Pull' prima, per integrare le modifiche.",
			"merge conflicts": "Ci sono conflitti di merge. Risolverli prima di eseguire commit.",
			"stash merge conflicts": "Si sono verificati conflitti di merge durante l'applicazione dell'accantonamento.",
			"auth failed specific": "Non è stato possibile eseguire l'autenticazione al repository remoto GIT:\r\n\r\n{0}",
			"auth failed": "Non è stato possibile eseguire l'autenticazione al repository remoto GIT.",
			"missing user info": "Assicurarsi di configurare 'user.name' e 'user.email' in GIT.",
			"learn more": "Altre informazioni",
			"empty commit": "L'operazione di commit è stata annullata a causa di un messaggio di commit vuoto.",
			"git error details": "GIT: {0}",
			"git error": "Errore GIT"
		},
		"dist/askpass": {
			"ssh passphrase": "Passphrase",
			"ssh authenticity prompt": "Continuare la connessione?",
			"ssh authenticity title": "\"{0}\" ha l'impronta digitale \"{1}\"",
			"ssh authenticity prompt yes": "sì",
			"ssh authenticity prompt no": "no"
		},
		"dist/protocolHandler": {
			"no git": "Non è stato possibile clonare il repository perché Git non è installato.",
			"download git": "Scarica GIT"
		},
		"dist/timelineProvider": {
			"git.timeline.email": "Indirizzo di posta elettronica",
			"git.timeline.source": "Cronologia GIT",
			"git.timeline.openComparison": "Apri confronto",
			"git.timeline.you": "Utente",
			"git.timeline.stagedChanges": "Modifiche preparate per il commit",
			"git.timeline.uncommitedChanges": "Modifiche non sottoposte a commit"
		},
		"dist/postCommitCommands": {
			"scm button commit and push tooltip": "Commit e push delle modifiche",
			"scm button commit to new branch and push tooltip": "Eseguire commit in un nuovo ramo e push delle modifiche",
			"scm button commit and sync tooltip": "Commit e sincronizzazione delle modifiche",
			"scm button commit to new branch and sync tooltip": "Esegui il commit in un nuovo ramo e sincronizza le modifiche",
			"scm button committing and pushing tooltip": "Commit e push delle modifiche in corso...",
			"scm button committing to new branch and pushing tooltip": "Eseguire commit in un nuovo ramo e pushing delle modifiche in corso...",
			"scm button committing and syncing tooltip": "Esecuzione del commit e sincronizzazione delle modifiche in corso...",
			"scm button committing to new branch and syncing tooltip": "Esecuzione il commit su un nuovo ramo e sincronizzazione delle modifiche...",
			"scm button commit and push title": "{0}commit e push",
			"scm button commit and sync title": "{0} commit e sincronizzazione",
			"scm button commit tooltip": "Eseguire il commit delle modifiche",
			"scm button commit to new branch tooltip": "Eseguire il commit delle modifiche apportate a un nuovo ramo",
			"scm button committing tooltip": "Commit delle modifiche in corso...",
			"scm button committing to new branch tooltip": "Esecuzione del commit delle modifiche nel nuovo ramo in corso...",
			"scm button commit title": "{0} Commit"
		},
		"dist/repository": {
			"index modified": "Indice modificato",
			"modified": "Modificato",
			"index added": "Indice aggiunto",
			"index deleted": "Indice eliminato",
			"deleted": "Eliminato",
			"index renamed": "Indice rinominato",
			"index copied": "Indice copiato",
			"untracked": "Non registrato",
			"ignored": "Ignorato",
			"intent to add": "Finalità da aggiungere",
			"both deleted": "Conflitto: eliminato dall'utente e da Microsoft",
			"added by us": "Conflitto: aggiunto da Microsoft",
			"deleted by them": "Conflitto: eliminato dall'utente",
			"added by them": "Conflitto: aggiunto dall'utente",
			"deleted by us": "Conflitto: eliminato da Microsoft",
			"both added": "Conflitto: aggiunto dall'utente e da Microsoft",
			"both modified": "Conflitto: modificato dall'utente e da Microsoft",
			"logLevel": "Log level: {0}",
			"open": "Apri",
			"open.merge": "Apri merge",
			"git.title.index": "{0} (indice)",
			"git.title.workingTree": "{0} (albero di lavoro)",
			"git.title.deleted": "{0} (eliminato)",
			"git.title.theirs": "{0} (versione server)",
			"git.title.ours": "{0} (versione utente)",
			"git.title.untracked": "{0} (non tracciati)",
			"commit": "Esegui commit",
			"merge changes": "Esegui merge delle modifiche",
			"staged changes": "Modifiche preparate per il commit",
			"changes": "Modifiche",
			"untracked changes": "Modifiche non tracciate",
			"push success": "Push avvenuto con successo.",
			"tooManyChangesWarning": "Sono state rilevate troppe modifiche. Di seguito verranno visualizzate solo le prime {0} modifiche.",
			"commit in rebase": "Non è possibile modificare il messaggio di commit durante una riassegnazione. Completare l'operazione corrente e usare invece una riassegnazione interattiva.",
			"commitMessageWhitespacesOnlyWarning": "Il messaggio di commit corrente contiene solo spazi vuoti",
			"commitMessageCountdown": "ancora {0} caratteri disponibili nella riga corrente",
			"commitMessageWarning": "{0} caratteri rispetto ai {1} disponibili nella riga corrente",
			"sync is unpredictable": "Sincronizzazione in corso. L'annullamento dell'operazione può causare gravi danni al repository",
			"always pull": "Esegui sempre il pull",
			"pull": "Esegui pull",
			"dont pull": "Non eseguire il pull",
			"pull branch maybe rebased": "Il ramo corrente '{0}' potrebbe essere stato riassegnato. Eseguire comunque il pull in esso?",
			"pull maybe rebased": "Il ramo corrente potrebbe essere stato riassegnato. Eseguire comunque il pull in esso?",
			"huge": "Il repository git '{0}' ha troppe modifiche attive - verrà attivato solo un sottoinsieme delle funzionalità di Git.",
			"neveragain": "Non visualizzare più questo messaggio",
			"add known": "Aggiungere '{0}' a .gitignore?",
			"yes": "Sì",
			"no": "No",
			"ok": "OK",
			"sync changes": "Sincronizza modifiche",
			"pull n": "Esegui il pull di {0} commit da {1}/{2}",
			"push n": "Esegui il push di {0} commit in {1}/{2}",
			"pull push n": "Esegui il pull di {0} e il push di {1} commit tra {2}/{3}",
			"commitMessageWithHeadLabel": "Messaggio ({0} per eseguire il commit in '{1}')",
			"commitMessage": "Messaggio ({0} per eseguire il commit)"
		},
		"dist/autofetch": {
			"yes": "Sì",
			"no": "No",
			"not now": "Chiedimelo in seguito",
			"suggest auto fetch": "Desideri che Code [esegua `git fetch` periodicamente]({0})?"
		},
		"dist/statusbar": {
			"rebasing": "Rebase in corso",
			"checkout": "{0}, Esegui il checkout del ramo/tag...",
			"publish to": "Pubblica in {0}",
			"publish to...": "Pubblica in...",
			"publish branch": "Pubblica Ramo",
			"syncing changes": "Sincronizzazione delle modifiche in corso..."
		},
		"dist/actionButton": {
			"scm button continue title": "{0} Continua",
			"scm button continuing tooltip": "Continuazione della riassegnazione...",
			"scm button continue tooltip": "Continua riassegnazione",
			"scm publish branch action button title": "{0} Pubblica Branch",
			"scm button publish branch running": "Pubblicazione Branch in corso...",
			"scm button publish branch": "Pubblica Branch",
			"syncing changes": "Sincronizzazione delle modifiche in corso...",
			"scm button sync description": "{0} Sincronizza modifiche{1}{2}"
		}
	}
}